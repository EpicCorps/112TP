import pygame, random, math
screenWidth, screenHeight = 1200, 800
screen = pygame.display.set_mode((screenWidth, screenHeight)) 
#   ____ ___  _   _ ____ _____  _    _   _ _____ ____  
#  / ___/ _ \| \ | / ___|_   _|/ \  | \ | |_   _/ ___| 
# | |  | | | |  \| \___ \ | | / _ \ |  \| | | | \___ \ 
# | |__| |_| | |\  |___) || |/ ___ \| |\  | | |  ___) |
#  \____\___/|_| \_|____/ |_/_/   \_\_| \_| |_| |____/ 
                                                     
#method for all sprite characters to load in their 4d movement animation
def loadSprites(spriteUrl, width, height):
    walkingRight = []
    walkingLeft = []
    walkingUp = []
    walkingDown = []
    spriteSheet = SpriteSheet(spriteUrl)
    for row in range(4):
        for col in range(3):
            image = spriteSheet.getImage(2 + 30 * col, 32 * row, 30, 32)
            image = pygame.transform.scale(image, (width, height))
            if row == 0: 
                walkingDown.append(image)
            elif row == 1:
                walkingLeft.append(image)
            elif row == 2:
                walkingRight.append(image)
            else:
                walkingUp.append(image)  
    return walkingRight, walkingLeft, walkingUp, walkingDown

#  ____  ____  ____  ___ _____ _____ 
# / ___||  _ \|  _ \|_ _|_   _| ____|   
# \___ \| |_) | |_) || |  | | |  _|  
#  ___) |  __/|  _ < | |  | | | |___  
# |____/|_|   |_| \_\___| |_| |_____|
#   ____ _        _    ____ ____  _____ ____  
#  / ___| |      / \  / ___/ ___|| ____/ ___| 
# | |   | |     / _ \ \___ \___ \|  _| \___ \ 
# | |___| |___ / ___ \ ___) |__) | |___ ___) |
#  \____|_____/_/   \_\____/____/|_____|____/ 
#copied from http://programarcadegames.com/python_examples/en/sprite_sheets/
class SpriteSheet(object):
    def __init__(self, file_name):
        self.ssheet = pygame.image.load(file_name)
    
    def getImage(self, x, y, width, height):
        image = pygame.Surface((width,height), pygame.SRCALPHA)
        image.blit(self.ssheet, (0, 0), (x, y, width, height))
        return image

#  _____ ___ _     _____ ____  
# |_   _|_ _| |   | ____/ ___| 
#   | |  | || |   |  _| \___ \ 
#   | |  | || |___| |___ ___) |
#   |_| |___|_____|_____|____/ 
class Tile(pygame.sprite.Sprite):
    size = 75
    def __init__(self, x, y, blockPath):
        super().__init__()
        self.blockPath = blockPath

class Wall(Tile):
    spriteSheet = SpriteSheet('DungeonTileSet.png')
    def __init__(self, x, y, givenImage = None):
        super().__init__(x, y, True)
        if givenImage == None:
            self.image = pygame.Surface((Tile.size,Tile.size))
            self.image.fill((0,0,0))
        else:
            self.image = self.getImage(givenImage)
        self.rect = self.image.get_rect()
        self.rect.x = x * self.rect.width
        self.rect.y = y * self.rect.height
    
    def getImage(self, givenImage):
        if givenImage == 'Top':
            return pygame.transform.scale(Wall.spriteSheet.getImage(42, 124, 16, 16).convert(), (Tile.size,Tile.size))
        elif givenImage == 'Bot':
            return pygame.transform.scale(Wall.spriteSheet.getImage(42, 156, 16, 16).convert(), (Tile.size, Tile.size))
        elif givenImage == 'LeftSide':
            return pygame.transform.scale(Wall.spriteSheet.getImage(22, 124, 14, 16).convert(), (Tile.size, Tile.size))
        elif givenImage == 'LeftBotCorner':
            return pygame.transform.scale(Wall.spriteSheet.getImage(22, 156, 14, 16).convert(), (Tile.size, Tile.size))
        elif givenImage == 'RightBotCorner':
            return pygame.transform.scale(Wall.spriteSheet.getImage(59, 156, 14, 16).convert(), (Tile.size, Tile.size))
        else:
            return pygame.transform.scale(Wall.spriteSheet.getImage(59, 124, 16, 16).convert(), (Tile.size, Tile.size))

class Floor(Tile):
    image = pygame.image.load('floor_1.png').convert()
    image = pygame.transform.scale(image, (Tile.size,Tile.size))
    image2 = pygame.image.load('floor_2.png').convert()
    image2 = pygame.transform.scale(image2, (Tile.size,Tile.size))
    image3 = pygame.image.load('floor_3.png').convert()
    image3 = pygame.transform.scale(image3, (Tile.size,Tile.size))
    image4 = pygame.image.load('floor_5.png').convert()
    image4 = pygame.transform.scale(image4, (Tile.size,Tile.size))
    # spriteSheet = SpriteSheet('grassTiles.png')
    # image5 = pygame.transform.scale(spriteSheet.getImage(0, 62, 31, 31), (Tile.size, Tile.size))
    image5 = pygame.image.load('floor_1_type2.png').convert()
    image5 = pygame.transform.scale(image5, (Tile.size, Tile.size))
    image6 = pygame.image.load('floor_6_type2.png').convert()
    image6 = pygame.transform.scale(image6, (Tile.size, Tile.size))
    image7 = pygame.image.load('floor_3_type2.png').convert()
    image7 = pygame.transform.scale(image7, (Tile.size, Tile.size))
    image8 = pygame.image.load('floor_4_type2.png').convert()
    image8 = pygame.transform.scale(image8, (Tile.size, Tile.size))
    def __init__(self, x, y, image = None):
        super().__init__(x, y, False)
        self.image = self.getTileImage(image)
        self.rect = self.image.get_rect()
        self.rect.x = x * self.rect.width
        self.rect.y = y * self.rect.height
    
    def getTileImage(self, image):
        if image == None:
            temp = random.randint(0,4)
            if temp == 0 or temp == 1:
                return Floor.image
            elif temp == 2:
                return Floor.image2
            elif temp == 3:
                return Floor.image3
            else:
                return Floor.image4
        else:
            if image == 'grass':
                temp = random.randint(0,4)
                if temp == 0 or temp == 1:
                    return Floor.image5
                elif temp == 2:
                    return Floor.image6
                elif temp == 3:
                    return Floor.image7
                else:
                    return Floor.image8

class Player(pygame.sprite.Sprite):
    def __init__ (self, x, y, width, height):
        super().__init__()
        self.vel = 5
        self.direction = 'D'
        self.walkingRight, self.walkingLeft, self.walkingUp, self.walkingDown = loadSprites('4DCharSprites/female/female 15-1.png', 60, 64)
        self.image = self.walkingDown[0]  
        self.rect = self.image.get_rect() 
        self.rect.x = x
        self.rect.y = y     
        self.health = 100     
        self.maxHealth = 100 
        self.attackTimer = 0

    def draw(self, screen, scrollX, scrollY):
        pygame.draw.rect(screen, (255, 0 ,0), (screenWidth // 15, screenHeight // 15
                                    , 300, 25))
        pygame.draw.rect(screen, (0, 255 ,0), (screenWidth // 15, screenHeight // 15,
                                 300 - ((self.maxHealth - self.health)/self.maxHealth * 300), 25))
        screen.blit(self.image, (self.rect.x - scrollX, self.rect.y - scrollY, self.rect.width, self.rect.height))
    
    def takeDamage(self, dmg):
        self.health -= dmg 
        if self.health <= 0:
            self.health = 0
        
    def move(self, dx, dy, all_Walls):
        if dx > 0 :
            self.direction = 'R'
            frame = (self.rect.x) // 30 % len(self.walkingRight)
            self.image = self.walkingRight[frame]
        elif dx < 0:
            self.direction = 'L'
            frame = (self.rect.x ) // 30 % len(self.walkingLeft)
            self.image = self.walkingLeft[frame]
        elif dy < 0:
            self.direction = 'Up'
            frame = self.rect.y // 30 % len(self.walkingUp)
            self.image = self.walkingUp[frame]
        else:
            self.direction = 'D'
            frame = self.rect.y //30 % len(self.walkingDown)
            self.image = self.walkingDown[frame]
        self.rect.x += dx
        self.rect.y += dy
        if self.hitWall(all_Walls):
            self.rect.x -= dx
            self.rect.y -= dy
    
    def hitWall(self, wallGroup):
        return pygame.sprite.spritecollide(self, wallGroup, False) != []

    def shoot(self, pos, all_Bullets, scrollX, scrollY):
        x, y = pos
        dx, dy = x - (self.rect.x  + self.rect.width//2 - scrollX), y - (self.rect.y + self.rect.width//2 - scrollY)
        dist = math.hypot(dx, dy)
        if dist != 0:
            dx, dy = dx / dist, dy / dist  
        now = pygame.time.get_ticks()
        if now - self.attackTimer > 250:
            self.attackTimer = now
            all_Bullets.add(Plasma(self.rect.x + self.rect.width//2, self.rect.y + self.rect.height//2, dx, dy, 10, 8))
          
   
    def fireBall(self, all_Abilities):
        angle = 0
        for i in range(8):
            all_Abilities.add(Fireball(self.rect.x + self.rect.width//2, self.rect.y + self.rect.height//2, angle))
            angle += math.pi / 4

    def setLocation(self, x, y):
        self.rect.x = x
        self.rect.y = y

#  _____ _   _ _____ __  __ ___ _____ ____  
# | ____| \ | | ____|  \/  |_ _| ____/ ___| 
# |  _| |  \| |  _| | |\/| || ||  _| \___ \ 
# | |___| |\  | |___| |  | || || |___ ___) |
# |_____|_| \_|_____|_|  |_|___|_____|____/                      
class Enemy(pygame.sprite.Sprite):
    def __init__(self):
        super().__init__()
        self.health = 10
        self.prevTime = 0
        self.idleCount = -1
        self.maxHealth = 10
        self.damage = 10 
        self.attackTimer = 0

    def hitWall(self, wallGroup):
        return pygame.sprite.spritecollide(self, wallGroup, False) != []

    def draw(self, screen, scrollX, scrollY):
        pygame.draw.rect(screen, (255, 0 ,0), (self.rect.x + 15 - scrollX, 
                                    self.rect.y - 20 - scrollY , self.rect.width, 10))
        pygame.draw.rect(screen, (0, 255 ,0), (self.rect.x + 15 - scrollX, 
                                    self.rect.y - 20 - scrollY, self.rect.width - (self.maxHealth - self.health)/self.maxHealth * self.rect.width, 10))
        screen.blit(self.image, (self.rect.x - scrollX, self.rect.y - scrollY, 
                                    self.rect.width, self.rect.height))
    
    def attack(self):
        now = pygame.time.get_ticks()
        
    def move(self, all_Walls):
        pass 

    def update(self, player, all_Walls):
        now = pygame.time.get_ticks()
        if now - self.prevTime > 75:
            self.prevTime = now
            self.idleCount += 1
            self.image = self.idleAnimation[self.idleCount % len(self.idleAnimation)]      
        self.move(all_Walls)
        if self.health <= 0:
            self.kill()

class Skeleton(Enemy):
    def __init__(self, x, y):
        super().__init__()
        self.width = 16
        self.height = 16
        self.idleAnimation = self.getIdleAnimation(self.width, self.height)
        self.image = self.idleAnimation[0]
        self.rect = self.image.get_rect()
        self.rect.x = x * Tile.size
        self.rect.y = y * Tile.size
    
    def getIdleAnimation(self, width, height):
        temp = []
        imageUrl = ['skelet_idle_anim_f0.png', 'skelet_idle_anim_f1.png', 
                    'skelet_idle_anim_f2.png', 'skelet_idle_anim_f3.png']
        for url in imageUrl:
            image = pygame.image.load(url).convert_alpha()
            image = pygame.transform.scale(image, (70, 70))
            temp.append(image)
        return temp

class Zombie(Enemy):
    def __init__(self, x, y):
        super().__init__()
        self.idleAnimation = self.getIdleAnimation()
        self.image = self.idleAnimation[0]
        self.rect = self.image.get_rect()
        self.rect.x = x * Tile.size
        self.rect.y = y * Tile.size
        self.vel = 5
        self.health = 100
        self.maxHealth = 100
        self.attackTimer = 0
    
    def getIdleAnimation(self):
        temp = []
        imageUrl = ['Dungeons/big_zombie_run_anim_f0.png', 'Dungeons/big_zombie_run_anim_f1.png', 
                    'Dungeons/big_zombie_run_anim_f2.png', 'Dungeons/big_zombie_run_anim_f3.png']
        for url in imageUrl:
            image = pygame.image.load(url).convert_alpha()
            image = pygame.transform.scale(image, (85, 115))
            temp.append(image)
        return temp

    #runs side to side 
    def move(self, all_Walls):
        if not self.hitWall(all_Walls):
            self.rect.x += self.vel 
        else:
            self.vel *= -1
            self.rect.x += self.vel
    
    def attack(self, player, all_Walls):
        if pygame.sprite.collide_rect(self, player):
            now = pygame.time.get_ticks()
            if now - self.attackTimer > 600:
                self.attackTimer = now
                player.takeDamage(self.damage)
                player.move(0, 40, all_Walls)
    
    def update(self, player, all_Walls):
        super().update(player, all_Walls)
        self.attack(player, all_Walls)
    

class Demon(Enemy):
    states = ['idle', 'attack']
    spriteSheet = SpriteSheet('4dCharSprites/Enemy/Enemy 17-5.png')
    def __init__(self, x, y):
        super().__init__()
        self.health = 30
        self.maxHealth = 30
        self.idleAnimation = self.getIdleAnimation()
        self.image = self.idleAnimation[0]
        self.rect = self.image.get_rect()
        self.rect.x = x * Tile.size
        self.rect.y = y * Tile.size
        self.vel = 3
        self.state = 'idle'
        self.angle = 0

    def getIdleAnimation(self):
        temp = []
        for i in range(3):
            image = Demon.spriteSheet.getImage(i * 32, 0, 32, 32)
            image = pygame.transform.scale(image, (64, 64))
            temp.append(image)
        return temp

    #follows the player around
    def move(self): 
        self.rect.x += self.dx
        self.rect.y += self.dy 
    
    def attack(self, all_EnemyBullets):
        now = pygame.time.get_ticks()
        if now - self.attackTimer > 450:
            self.attackTimer = now

    def trackPlayer(self, player, all_EnemyBullets):
        dx, dy = (player.rect.x  + player.rect.width//2) - (self.rect.x + self.rect.width//2), (player.rect.y + player.rect.width//2) - (self.rect.y + self.rect.width//2)
        dist = math.hypot(dx, dy)
        if dist != 0:
            dx, dy = dx / dist, dy / dist  # Normalize.
            # Move along this normalized vector towards the player at current speed.
            self.rect.x += dx * self.vel
            self.rect.y += dy * self.vel
        now = pygame.time.get_ticks()
        if now - self.attackTimer > 500:
            self.attackTimer = now
            all_EnemyBullets.add(Plasma(self.rect.x + self.rect.width//2, self.rect.y + self.rect.height//2, dx, dy))
            
    
    def checkState(self, player):
        distance = math.sqrt((player.rect.x + player.rect.width//2 - self.rect.x + self.rect.width// 2) ** 2 + 
                            (player.rect.y + player.rect.height//2 - self.rect.y + self.rect.height// 2) ** 2)
        if distance < 6 * Tile.size:
            self.state = 'Attack'
        else:
            self.state = 'idle'

    def update(self, player, all_Walls, all_EnemyBullets):
        self.checkState(player)
        if self.state == 'Attack':
            # self.attack(all_EnemyBullets)
            self.trackPlayer(player, all_EnemyBullets)
        now = pygame.time.get_ticks()
        if now - self.prevTime > 75:
            self.prevTime = now
            self.idleCount += 1
            self.image = self.idleAnimation[self.idleCount % len(self.idleAnimation)]      
        if self.health <= 0:
            self.kill()
        
#sprite from https://uilleaggodwin.itch.io/roguelike-dungeon-asset-bundle
class Boss(Enemy):
    states = ['Burst', 'Track', 'Idle', 'Homing']
    def __init__(self, x, y):
        super().__init__()
        self.health = 250
        self.maxHealth = 250
        self.animation = self.loadAnimation()
        self.image = self.animation[0]
        self.rect = self.image.get_rect()
        self.rect.x = x * Tile.size
        self.rect.y = y * Tile.size
        self.state = 'idle'
        self.stateTimer = 0
        self.spriteTimer = 0
        self.attackTimer = 0
        self.idleCount = 0
    
    def loadAnimation(self):
        temp = []
        imageUrl = ['AllSprites/SkeletonKing_Walk_0.png', 'AllSprites/SkeletonKing_Walk_1.png',
                    'AllSprites/SkeletonKing_Walk_2.png', 'AllSprites/SkeletonKing_Walk_3.png']
        for url in imageUrl:
            image = pygame.image.load(url).convert_alpha()
            image = pygame.transform.scale(image, (350, 350))
            temp.append(image)
        return temp

    #chooses a random state of attack 
    def changeState(self):
        now = pygame.time.get_ticks()
        if now - self.stateTimer > 1000:
            self.stateTimer = now
            self.state = random.choice(Boss.states)
    
    def burstAttack(self, all_EnemyBullets):
        angle = 0
        for i in range(16):
            all_EnemyBullets.add(Fireball(self.rect.x + self.rect.width//2, self.rect.y + self.rect.height//2, angle, 10, 5, 'Energy Ball'))
            angle += math.pi / 8
    
    def trackingAttack(self, player, all_EnemyBullets):
        playerX = player.rect.x + player.rect.width // 2
        playerY = player.rect.y + player.rect.height // 2
        dy = playerY - (self.rect.y + self.rect.width // 2)
        dx = playerX - (self.rect.x + self.rect.height // 2)
        
        if dy < 0 and dx > 0:
            angle = math.atan(dy / dx)
        elif dy > 0 and dx < 0:
            angle = math.pi + math.atan(dy / dx)
        elif dy < 0 and dx < 0:
            angle = math.pi + math.atan(dy / dx)
        elif dy > 0 and dx > 0:
            angle = math.atan(dy / dx)
        elif dy == 0 and dx > 0:
            angle = 0 
        elif dy == 0 and dx < 0:
            angle = math.pi
        elif dx == 0 and dy < 0:
            angle = math.pi / 2
        else:
            angle = -math.pi / 2
        all_EnemyBullets.add(Fireball(self.rect.x + self.rect.width // 2, self.rect.y + self.rect.height // 2, angle, 5, 8, 'Star'))                           
    
    def shootHomingBullets(self, all_EnemyBullets):
        all_EnemyBullets.add(HomingBullet(self.rect.x + self.rect.width // 2, self.rect.y + self.rect.height // 2))

    #loops through idle animation
    def updateSprite(self):
         now = pygame.time.get_ticks()
         if now - self.spriteTimer > 75:
            self.spriteTimer = now
            self.idleCount += 1
            self.image = self.animation[self.idleCount % len(self.animation)] 

    def update(self, player, all_EnemyBullets):
        self.changeState()
        self.updateSprite()
        now = pygame.time.get_ticks()
        if self.state == 'Burst':
            if now - self.attackTimer > 600:
                self.attackTimer = now
                self.burstAttack(all_EnemyBullets)
        elif self.state == 'Track':
            if now - self.attackTimer > 100:
                self.attackTimer = now
                self.trackingAttack(player, all_EnemyBullets)
        elif self.state == 'Homing':
            if now - self.attackTimer > 300:
                self.attackTimer = now
                self.shootHomingBullets(all_EnemyBullets)
        elif self.state == 'Idle':
            pass 
        if self.health <= 0:
            self.kill()


#  ____  ____   ___      _ _____ ____ _____ ___ _     _____ ____  
# |  _ \|  _ \ / _ \    | | ____/ ___|_   _|_ _| |   | ____/ ___| 
# | |_) | |_) | | | |_  | |  _|| |     | |  | || |   |  _| \___ \ 
# |  __/|  _ <| |_| | |_| | |__| |___  | |  | || |___| |___ ___) |
# |_|   |_| \_\\___/ \___/|_____\____| |_| |___|_____|_____|____/                                                             
class Plasma(pygame.sprite.Sprite):
    spriteSheet = SpriteSheet('AllSprites/projectiles.png')
    def __init__(self, x, y, dx, dy, damage = 2, vel = 6):
        super().__init__()
        self.image = Plasma.spriteSheet.getImage(16, 16, 15, 15)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.vel = vel
        self.dx = dx
        self.dy = dy
        self.damage = damage
    
    def update(self):
        self.rect.x += self.dx * self.vel
        self.rect.y += self.dy * self.vel
    
    def draw(self, screen, scrollX, scrollY):
        screen.blit(self.image, (self.rect.x - scrollX, self.rect.y - scrollY, self.rect.width, self.rect.height))

class Bullet(pygame.sprite.Sprite):
    def __init__(self, x, y, width, height, direction):
        super().__init__()
        self.image = pygame.Surface((width, height), pygame.SRCALPHA)
        pygame.draw.circle(self.image, (255,255,0), (width//2, height//2), width//2)
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.vel = 10
        self.direction = direction
        self.damage = 5
    
    def draw(self, screen, scrollX, scrollY):
        x, y, width, height = self.rect
        screen.blit(self.image, (x - scrollX, y - scrollY, width, height))
    
    def update(self):
        if self.direction == 'R':
            self.rect.x += self.vel
        elif self.direction == 'L':
            self.rect.x -= self.vel
        elif self.direction == 'Up':
            self.rect.y -= self.vel
        elif self.direction == 'D':
            self.rect.y += self.vel

class Fireball(pygame.sprite.Sprite):
    spriteSheet = SpriteSheet('AllSprites/Fireball.png')
    spriteSheet2 = SpriteSheet('AllSprites/projectiles.png')
    def __init__(self, x, y, angle, damage = 20, vel = 8, element = None):
        super().__init__()
        self.element = element
        self.angle = angle
        self.image = self.loadImage()
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.vel = vel
        self.dx = self.vel * math.cos(self.angle)
        self.dy = self.vel * math.sin(self.angle)
        self.damage = damage
    
    def loadImage(self):
        if self.element == 'Energy Ball':
            image = Fireball.spriteSheet2.getImage(192, 16, 15, 15)
            image = pygame.transform.scale(image, (45, 45))
        elif self.element == 'Star':
            image = Fireball.spriteSheet2.getImage(64, 64, 15, 15)
            image = pygame.transform.scale(image, (45, 45))
        else:
            image = Fireball.spriteSheet.getImage(21, 23, 28, 16)
            image = pygame.transform.scale(image, (56, 32))
        image = pygame.transform.rotate(image, 360 - math.degrees(self.angle))
        return image 
    
    def update(self):
        self.rect.x += self.dx
        self.rect.y += self.dy
    
    def draw(self, screen, scrollX, scrollY):
        screen.blit(self.image, (self.rect.x - scrollX, self.rect.y - scrollY, self.rect.width, self.rect.height))

class HomingBullet(pygame.sprite.Sprite):
    spriteSheet = SpriteSheet('AllSprites/projectiles.png')
    def __init__(self, x, y):
        super().__init__()
        self.image = self.loadImage()
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.vel = 4
        self.damage = 5
        self.liveTime = 0
        
    def loadImage(self):
        image = HomingBullet.spriteSheet.getImage(98, 32, 11, 16)
        image = pygame.transform.scale(image, (33, 48))
        return image
    #from https://stackoverflow.com/questions/20044791/how-to-make-an-enemy-follow-the-player-in-pygame
    def trackPlayer(self, player):
        dx, dy = (player.rect.x  + player.rect.width//2) - (self.rect.x + self.rect.width//2), (player.rect.y + player.rect.width//2) - (self.rect.y + self.rect.width//2)
        dist = math.hypot(dx, dy)
        if dist != 0:
            dx, dy = dx / dist, dy / dist
            self.rect.x += dx * self.vel
            self.rect.y += dy * self.vel
    
    def update(self, player):
        self.trackPlayer(player)
        self.liveTime += 1
    
    def draw(self, screen, scrollX, scrollY):
        screen.blit(self.image, (self.rect.x - scrollX, self.rect.y - scrollY, self.rect.width, self.rect.height))

class Portal(pygame.sprite.Sprite):
    spriteSheet = SpriteSheet('AllSprites/BluePortal.png')
    spriteSheet2 = SpriteSheet('AllSprites/RedPortal.png')
    def __init__(self, x, y, sendLocation = None):
        super().__init__()
        self.sendLocation = sendLocation
        self.animation = self.getAnimation()
        self.image = self.animation[0]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.prevTime = 0
        self.animationCount = 0
    
    def getAnimation(self):
        temp = []
        if self.sendLocation == 'Level3':
            for y in range(3):
                for x in range(5):
                    image = Portal.spriteSheet2.getImage(192 * x, 192 * y, 192, 192)
                    temp.append(image)
        else:
            for y in range(3):
                for x in range(5):
                    image = Portal.spriteSheet.getImage(192 * x, 192 * y, 192, 192)
                    temp.append(image)
        return temp
    
    def draw(self, screen, scrollX, scrollY):
        screen.blit(self.image, (self.rect.x - scrollX, self.rect.y - scrollY, self.rect.width, self.rect.height))
    
    def update(self):
        now = pygame.time.get_ticks()
        if now - self.prevTime > 50:
            self.prevTime = now
            self.animationCount += 1
            self.image = self.animation[self.animationCount % len(self.animation)]
    

#  __  __    _    ____     ____ _____ _   _ _____ ____      _  _____ ___  ____  
# |  \/  |  / \  |  _ \   / ___| ____| \ | | ____|  _ \    / \|_   _/ _ \|  _ \ 
# | |\/| | / _ \ | |_) | | |  _|  _| |  \| |  _| | |_) |  / _ \ | || | | | |_) |
# | |  | |/ ___ \|  __/  | |_| | |___| |\  | |___|  _ <  / ___ \| || |_| |  _ < 
# |_|  |_/_/   \_\_|      \____|_____|_| \_|_____|_| \_\/_/   \_\_| \___/|_| \_\

#got idea and adapted from https://www.youtube.com/watch?v=fGvvi5vR17s&t=3265s
class GameMap(object):
    def __init__(self, maxRooms = 10, maxRoomSize = 14, minRoomSize = 8):
        self.maxRooms = maxRooms
        self.maxRoomSize = maxRoomSize
        self.minRoomSize = minRoomSize
        self.map = []
        self.rooms = self.generate(50, 50)
        self.startingPoint
    
    def generate(self, width, height):
        self.map = [[Wall(x, y) for y in range(height)] for x in range(width)]

        rooms = []
        
        for i in range(self.maxRooms):
            # random width and height
            w = random.randint(self.minRoomSize, self.maxRoomSize)
            h = random.randint(self.minRoomSize, self.maxRoomSize)
			# random position within map boundries
            x = random.randint(0, width - w - 1)
            y = random.randint(0, height - h - 1)
            newRoom = pygame.Rect(x, y, w, h)

            #check intersection between other rooms
            if newRoom.collidelist(rooms) == -1:
                self.createRoom(newRoom)
                rooms.append(newRoom)
            for i in range(len(rooms) - 1):
                prev, current = rooms[i], rooms[i + 1]
                prevX, prevY = prev.x + prev.width // 2, prev.y + prev.height // 2
                currentX, currentY = current.x + current.width // 2, current.y + current.height // 2

                if random.randint(0, 1) == 0:
                    self.createVerticalTunnel(prevY, currentY, prevX)
                    self.createHorizontalTunnel(prevX, currentX, currentY)
                else:
                    self.createHorizontalTunnel(prevX, currentX, prevY)
                    self.createVerticalTunnel(prevY, currentY, currentX)
            self.startingPoint = ((rooms[0].x + rooms[0].width // 2) * Tile.size, 
                                 (rooms[0].y + rooms[0].height //2) * Tile.size)
        print(f"Number of Rooms: {len(rooms)}")
        return rooms

    def createRoom(self, room):
        for i in range(room.width):
            for j in range(room.height):
                if j + 1 == room.height and i + 1 == room.width:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'RightBotCorner')
                elif i == 0 and j + 1 == room.height:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'LeftBotCorner')
                elif i == 0:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'LeftSide')
                elif i + 1 == room.width:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'RightSide')
                elif j == 0:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'Bot')
                elif j + 1 == room.height:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'Top')
                else:
                    self.map[room.x + i][room.y + j] = Floor(room.x + i, room.y + j)
    
    def createVerticalTunnel(self, y1, y2, x):
        for y in range(min(y1, y2), max(y1, y2) + 1):
            self.map[x][y] = Floor(x, y)
    
    def createHorizontalTunnel(self, x1, x2, y):
        for x in range(min(x1, x2), max(x1, x2) + 1):
            self.map[x][y] = Floor(x, y)

    def generateEnemies(self, all_Walls):
        group = pygame.sprite.Group()
        for room in self.rooms:
            temp = pygame.Rect(room.x + 1, room.y + 1, room.width -4, room.height - 4)
            for i in range(3):
                choice = random.randint(0,2)
                if choice == 0:
                    group.add(Zombie(random.randint(temp.x, temp.x - 1 + temp.width),
                                    random.randint(temp.y, temp.y - 1 + temp.height)))
                elif choice == 1:
                    group.add(Skeleton(random.randint(temp.x, temp.x - 1 + temp.width),
                                    random.randint(temp.y, temp.y - 1 + temp.height)))
                elif choice == 2:
                    group.add(Demon(random.randint(temp.x, temp.x - 1 + temp.width),
                                    random.randint(temp.y, temp.y - 1 + temp.height)))
        return group

    #returns a sprite group containing all the tiles in the map
    def getGroup(self):
        tileGroup = pygame.sprite.Group()
        wallGroup = pygame.sprite.Group()
        for row in range(len(self.map)):
            for col in range(len(self.map[0])):
                tileGroup.add(self.map[row][col])
                if type(self.map[row][col]) == Wall:
                    wallGroup.add(self.map[row][col])
        return tileGroup, wallGroup
    
    def draw(self, screen, scrollX, scrollY):
        for x in range(len(self.map)):
            for y in range(len(self.map[0])):
                currTile = self.map[x][y]
                screen.blit(currTile.image, (x * currTile.rect.width - scrollX, y * currTile.rect.height - scrollY))

    def generatePortals(self, all_Walls):
        temp = pygame.sprite.Group()
        room = self.rooms[-1]
        temp.add(Portal((room.x + room.width//2) * Tile.size, (room.y + room.height//2) * Tile.size, 'Level3'))
        print(len(temp))
        return temp

class CellularAutomataMap(object):
    def __init__(self):
        self.width = 30
        self.height = 30
        self.wallProb = 0.4
        self.numSimulation = 6
        self.neighbors = 4
        self.generate(self.width, self.height)
        self.numEnemies = 10
    
    def generate(self, width, height):
        self.map = [[0 for y in range(height)] for x in range(width)]
        self.randomFill()

        for simulation in range(self.numSimulation):
            self.map = self.simulationStep()
        self.createBorder()
        self.translateMapToTiles()

    def randomFill(self):
        # wall are 1
        # floor are 0
        #leave an outer layer of walls 
        for y in range(self.height):
            for x in range(self.width):
                if random.random() <= self.wallProb:
                    self.map[x][y] = 1 

    #returns the number of adjacent walls to a given cell
    def getAdjacentWalls(self, x, y):
        wallCount = 0
        for i in [-1, 0, 1]:
            for j in [-1, 0 , 1]:
                if i != 0 or j != 0:
                    if x + i < 0 or x + i >= self.width or y + j < 0 or y + j >= self.height:
                        wallCount += 1
                    elif self.map[x + i][y + j] == 1:
                        wallCount += 1
        return wallCount

    def simulationStep(self):
        newMap = [[0 for y in range(self.height)] for x in range(self.width)]
        for x in range(self.width):
            for y in range(self.height):
                numWalls = self.getAdjacentWalls(x, y)
                if self.map[x][y] == 1:
                    if numWalls < 3:
                        newMap[x][y] = 0 
                    else:
                        newMap[x][y] = 1
                else:
                    if numWalls > 4:
                        newMap[x][y] = 1
                    else:
                        newMap[x][y] = 0
        return newMap
    
    def createBorder(self):
        for x in range(self.width):
            self.map[x][0] = 1
            self.map[x][self.height - 1] = 1
        for y in range(self.height):
            self.map[0][y] = 1
            self.map[self.width - 1][y] = 1
      
    #turns the 2d array of 0 and 1 to floor and wall tiles 
    def translateMapToTiles(self):
        for x in range(self.width):
            for y in range(self.height):
                if self.map[x][y] == 1:
                    self.map[x][y] = Wall(x, y)
                else:
                    self.map[x][y] = Floor(x, y, 'grass')
    
    #returns a sprite group containing all the tiles in the map
    def getGroup(self):
        tileGroup = pygame.sprite.Group()
        wallGroup = pygame.sprite.Group()
        for x in range(self.width):
            for y in range(self.height):
                tileGroup.add(self.map[x][y])
                if type(self.map[x][y]) == Wall:
                    wallGroup.add(self.map[x][y])
        return tileGroup, wallGroup

    def draw(self, screen, scrollX, scrollY):
        for x in range(self.width):
            for y in range(self.height):
                currTile = self.map[x][y]
                screen.blit(currTile.image, (x * currTile.rect.width - scrollX, y * currTile.rect.height - scrollY))

    def getLargerAdjacentWalls(self, x, y):
        wallCount = 0
        for i in [-2, -1, 0, 1, 2]:
            for j in [-2, -1, 0, 1, 2]:
                if i != 0 or j != 0:
                    if x + i < 0 or x + i >= self.width or y + j < 0 or y + j >= self.height:
                        wallCount += 1
                    elif self.map[x + i][y + j] == 1:
                        wallCount += 1
        return wallCount

    def randomPoint(self):
        while True:
            x = random.randint(1, self.width - 1)
            y = random.randint(1, self.height - 1)
            if type(self.map[x][y]) == Floor and self.getLargerAdjacentWalls(x, y) == 0:
                return (x * Tile.size, y * Tile.size)
    
    def generateEnemies(self, all_Walls):
        temp = pygame.sprite.Group()
        count = 0
        for i in range(self.numEnemies):
            x, y = self.randomPoint()
            temp.add(Skeleton(x / Tile.size, y / Tile.size))
            x, y = self.randomPoint()
            temp.add(Zombie(x / Tile.size, y / Tile.size))
            x, y = self.randomPoint()
            temp.add(Demon(x / Tile.size, y / Tile.size))

        #check that they are in the map
        for mob in temp:
            if mob.hitWall(all_Walls):
                mob.kill()
        print(len(temp))
        return temp
    
    def generatePortals(self, all_Walls):
        temp = pygame.sprite.Group()
        for i in range(3):
            x, y = self.randomPoint()
            temp.add(Portal(x, y, 'Level1'))
        for portal in temp:
            if pygame.sprite.spritecollide(portal, all_Walls, False) != []:
                portal.kill()
        return temp

class RoomMap(object):
    def __init__(self):
        self.roomWidth = 15
        self.roomHeight = 15
        self.map = []
        self.room = self.generate()

    def generate(self):
        self.map = [[Wall(x, y) for y in range(20)] for x in range(20)]

        x = random.randint(0, 20 - self.roomWidth - 1)
        y = random.randint(0, 20 - self.roomHeight - 1)
        newRoom = pygame.Rect(x, y, self.roomWidth, self.roomHeight)
        self.startingPoint = ((newRoom.x + newRoom.width // 3) * Tile.size, 
                            (newRoom.y + newRoom.height // 3) * Tile.size)
        self.createRoom(newRoom)
        return newRoom

    def createRoom(self, room):
        for i in range(room.width):
            for j in range(room.height):
                if j + 1 == room.height and i + 1 == room.width:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'RightBotCorner')
                elif i == 0 and j + 1 == room.height:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'LeftBotCorner')
                elif i == 0:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'LeftSide')
                elif i + 1 == room.width:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'RightSide')
                elif j == 0:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'Bot')
                elif j + 1 == room.height:
                    self.map[room.x + i][room.y + j] = Wall(room.x + i, room.y + j, 'Top')
                else:
                    self.map[room.x + i][room.y + j] = Floor(room.x + i, room.y + j)

    def draw(self, screen, scrollX, scrollY):
            for x in range(len(self.map)):
                for y in range(len(self.map[0])):
                    currTile = self.map[x][y]
                    screen.blit(currTile.image, (x * currTile.rect.width - scrollX, y * currTile.rect.height - scrollY))

    def generateBoss(self):
        temp = pygame.sprite.Group()
        x = self.room.x + self.room.width // 2
        y = self.room.y + self.room.height // 2
        temp.add(Boss(x - 2, y - 3))
        return temp 
    
    #returns a sprite group containing all the tiles in the map
    def getGroup(self):
        tileGroup = pygame.sprite.Group()
        wallGroup = pygame.sprite.Group()
        for x in range(20):
            for y in range(20):
                tileGroup.add(self.map[x][y])
                if type(self.map[x][y]) == Wall:
                    wallGroup.add(self.map[x][y])
        return tileGroup, wallGroup


#   ____    _    __  __ _____   __  __ _____ _____ _   _  ___  ____  ____  
#  / ___|  / \  |  \/  | ____| |  \/  | ____|_   _| | | |/ _ \|  _ \/ ___| 
# | |  _  / _ \ | |\/| |  _|   | |\/| |  _|   | | | |_| | | | | | | \___ \ 
# | |_| |/ ___ \| |  | | |___  | |  | | |___  | | |  _  | |_| | |_| |___) |
#  \____/_/   \_\_|  |_|_____| |_|  |_|_____| |_| |_| |_|\___/|____/|____/ 

class Game(object):
    def __init__(self):
        self.screenWidth, self.screenHeight = 1200, 800 
        self.screen = pygame.display.set_mode((self.screenWidth, self.screenHeight)) 
        pygame.display.set_caption("Tp0")  
        self.scrollX = 0
        self.scrollY = 0
        self.scrollMargin = 350
        self.all_Sprites = pygame.sprite.Group()
        self.all_Bullets = pygame.sprite.Group()
        self.all_Abilities = pygame.sprite.Group()
        self.all_Portals = pygame.sprite.Group()
        self.all_Walls = pygame.sprite.Group()
        self.all_Tiles = pygame.sprite.Group()
        self.all_EnemyBullets = pygame.sprite.Group()
        self.all_Boss = pygame.sprite.Group()

        self.gameMap = CellularAutomataMap()
        self.all_Tiles, self.all_Walls = self.gameMap.getGroup()
        playerX, playerY = self.gameMap.randomPoint()
        self.player = Player(playerX, playerY, 60, 64)
        self.all_Sprites = self.gameMap.generateEnemies(self.all_Walls)
        self.all_Portals = self.gameMap.generatePortals(self.all_Walls)
        pygame.init()

    def run(self):
        clock = pygame.time.Clock()
        run = True

        while run:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    run = False
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_f: self.player.fireBall(self.all_Abilities)
                if event.type == pygame.MOUSEBUTTONDOWN:
                    pos = pygame.mouse.get_pos()
                    self.player.shoot(pos, self.all_Bullets, self.scrollX, self.scrollY,)

            #check key events
            keys = pygame.key.get_pressed()
            if keys[pygame.K_a]:
                self.player.move(-5, 0, self.all_Walls)
            elif keys[pygame.K_d]:
                self.player.move(5, 0, self.all_Walls)
            elif keys[pygame.K_w]:
                self.player.move(0, -5, self.all_Walls)
            elif keys[pygame.K_s]:
                self.player.move(0, 5, self.all_Walls)
            elif keys[pygame.K_r]:
                self.gameMap = GameMap()
                playerX, playerY = self.gameMap.startingPoint
                self.player.setLocation(playerX, playerY)
                self.all_Tiles, self.all_Walls = self.gameMap.getGroup()
                self.all_Sprites.empty()
                self.all_Sprites = self.gameMap.generateEnemies(self.all_Walls)
                self.all_Portals = self.gameMap.generatePortals(self.all_Walls)
            elif keys[pygame.K_c]:
                self.all_Sprites.empty()
                self.gameMap = CellularAutomataMap()
                self.all_Tiles, self.all_Walls = self.gameMap.getGroup()
                self.all_Sprites = self.gameMap.generateEnemies(self.all_Walls)
                playerX, playerY = self.gameMap.randomPoint()
                self.player.setLocation(playerX, playerY)
                self.all_Portals = self.gameMap.generatePortals(self.all_Walls)
                
            self.checkScroll()
            self.gameCollisions()

            #portal collision
            portals = pygame.sprite.spritecollide(self.player, self.all_Portals, False, False)
            if len(portals) > 0:
                self.all_Sprites.empty()
                self.all_Portals.empty()
                self.all_Boss.empty()
                self.all_EnemyBullets.empty()
                if portals[0].sendLocation == 'Level1':
                    self.gameMap = GameMap()
                    playerX, playerY = self.gameMap.startingPoint
                    self.all_Sprites = self.gameMap.generateEnemies(self.all_Walls)
                    self.all_Portals = self.gameMap.generatePortals(self.all_Walls)
                    self.all_Tiles, self.all_Walls = self.gameMap.getGroup()
                    self.player.setLocation(playerX, playerY)
                elif portals[0].sendLocation == 'Level2':
                    self.gameMap = CellularAutomataMap()
                    playerX, playerY = self.gameMap.randomPoint()
                    self.all_Sprites = self.gameMap.generateEnemies(self.all_Walls)
                    self.all_Portals = self.gameMap.generatePortals(self.all_Walls)
                    self.all_Tiles, self.all_Walls = self.gameMap.getGroup()
                    self.player.setLocation(playerX, playerY)
                elif portals[0].sendLocation == 'Level3':
                    self.gameMap = RoomMap()
                    self.all_Tiles, self.all_Walls = self.gameMap.getGroup()
                    playerX, playerY = self.gameMap.startingPoint
                    self.player = Player(playerX, playerY, 60, 64)
                    self.all_Tiles, self.all_Walls = self.gameMap.getGroup()
                    self.player.setLocation(playerX, playerY)
                    self.all_Boss = self.gameMap.generateBoss()

            self.updateGame()
            self.redrawAll()

            pygame.display.set_caption(str(clock.get_fps())) 
            clock.tick(60)
        pygame.quit()


    def redrawAll(self):
        self.screen.fill((0,0,0))
        #screen.blit(bg, ((-scrollX % screenWidth) - screenWidth,0))
        #screen.blit(bg, ((-scrollX + screenWidth ) % screenWidth, 0))
        self.gameMap.draw(self.screen, self.scrollX, self.scrollY)
        for sprite in self.all_Sprites:
            sprite.draw(self.screen, self.scrollX, self.scrollY)
        for sprite in self.all_Bullets:
            sprite.draw(self.screen, self.scrollX, self.scrollY)
        for sprite in self.all_Abilities:
            sprite.draw(self.screen, self.scrollX, self.scrollY)
        for sprite in self.all_Portals:
            sprite.draw(self.screen, self.scrollX, self.scrollY)
        for sprite in self.all_Boss:
            sprite.draw(self.screen, self.scrollX, self.scrollY)
        for sprite in self.all_EnemyBullets:
            sprite.draw(self.screen, self.scrollX, self.scrollY)
        self.player.draw(self.screen, self.scrollX, self.scrollY)
        pygame.display.update()

    def updateGame(self):
        now = pygame.time.get_ticks()
        for sprite in self.all_Sprites:
            if type(sprite) == Demon:
                sprite.update(self.player, self.all_Walls, self.all_EnemyBullets)
            else:
                sprite.update(self.player, self.all_Walls)
        for sprite in self.all_Boss:
            sprite.update(self.player, self.all_EnemyBullets)
        for sprite in self.all_EnemyBullets:
            if type(sprite) == HomingBullet:
                sprite.update(self.player)
                if sprite.liveTime > 200: sprite.kill()
            else:
                sprite.update()
        self.all_Bullets.update()
        self.all_Abilities.update()
        self.all_Portals.update()

    def gameCollisions(self):
        #bullet collision 
        pygame.sprite.groupcollide(self.all_EnemyBullets, self.all_Walls, True, False)
        pygame.sprite.groupcollide(self.all_Bullets, self.all_Walls, True, False)
        hit = pygame.sprite.groupcollide(self.all_Sprites, self.all_Bullets, False, True)
        for enemySprite, bulletList in hit.items():
            for item in bulletList:
                enemySprite.health -= item.damage
        hit = pygame.sprite.groupcollide(self.all_Boss, self.all_Bullets, False, True)
        for enemySprite, bulletList in hit.items():
            for item in bulletList:
                enemySprite.health -= item.damage
        #abilities collision
        pygame.sprite.groupcollide(self.all_Abilities, self.all_Walls, True, False)
        hit = pygame.sprite.groupcollide(self.all_Sprites, self.all_Abilities, False, True)
        for enemySprite, abilitiesList in hit.items():
            for item in abilitiesList:
                enemySprite.health -= item.damage
        hit = pygame.sprite.groupcollide(self.all_Boss, self.all_Abilities, False, True)
        for enemySprite, abilitiesList in hit.items():
            for item in abilitiesList:
                enemySprite.health -= item.damage
        #player collide damage
        hit = pygame.sprite.spritecollide(self.player, self.all_EnemyBullets, True)
        for item in hit:
            self.player.takeDamage(item.damage)

    def checkScroll(self):
        if self.player.rect.x - self.scrollX < self.scrollMargin:
            self.scrollX = self.player.rect.x - self.scrollMargin 
        if self.player.rect.x > self.scrollX + self.screenWidth - self.scrollMargin - self.player.rect.width:
            self.scrollX = self.player.rect.x - self.screenWidth + self.scrollMargin + self.player.rect.width
        
        if self.player.rect.y - self.scrollY < self.scrollMargin: 
            self.scrollY = self.player.rect.y - self.scrollMargin
        if self.player.rect.y > self.scrollY + self.screenHeight - self.scrollMargin - self.player.rect.height:
            self.scrollY = self.player.rect.y - self.screenHeight + self.scrollMargin + self.player.rect.height
  
Game().run()
